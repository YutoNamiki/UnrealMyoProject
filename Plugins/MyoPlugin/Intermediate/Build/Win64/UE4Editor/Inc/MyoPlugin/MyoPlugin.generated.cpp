// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Boilerplate C++ definitions for a single module.
	This is automatically generated by UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "Private/MyoPluginPrivatePCH.h"
#include "MyoPlugin.generated.dep.h"
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCodeMyoPlugin() {}
static class UEnum* MyoStreamEmgType_StaticEnum()
{
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern MYOPLUGIN_API class UEnum* Z_Construct_UEnum_MyoPlugin_MyoStreamEmgType();
		extern MYOPLUGIN_API class UPackage* Z_Construct_UPackage_MyoPlugin();
		Singleton = GetStaticEnum(Z_Construct_UEnum_MyoPlugin_MyoStreamEmgType, Z_Construct_UPackage_MyoPlugin(), TEXT("MyoStreamEmgType"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_MyoStreamEmgType(MyoStreamEmgType_StaticEnum, TEXT("/Script/MyoPlugin"));
static class UEnum* MyoUnlockType_StaticEnum()
{
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern MYOPLUGIN_API class UEnum* Z_Construct_UEnum_MyoPlugin_MyoUnlockType();
		extern MYOPLUGIN_API class UPackage* Z_Construct_UPackage_MyoPlugin();
		Singleton = GetStaticEnum(Z_Construct_UEnum_MyoPlugin_MyoUnlockType, Z_Construct_UPackage_MyoPlugin(), TEXT("MyoUnlockType"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_MyoUnlockType(MyoUnlockType_StaticEnum, TEXT("/Script/MyoPlugin"));
static class UEnum* MyoLockingPolicy_StaticEnum()
{
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern MYOPLUGIN_API class UEnum* Z_Construct_UEnum_MyoPlugin_MyoLockingPolicy();
		extern MYOPLUGIN_API class UPackage* Z_Construct_UPackage_MyoPlugin();
		Singleton = GetStaticEnum(Z_Construct_UEnum_MyoPlugin_MyoLockingPolicy, Z_Construct_UPackage_MyoPlugin(), TEXT("MyoLockingPolicy"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_MyoLockingPolicy(MyoLockingPolicy_StaticEnum, TEXT("/Script/MyoPlugin"));
static class UEnum* MyoVibrationType_StaticEnum()
{
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern MYOPLUGIN_API class UEnum* Z_Construct_UEnum_MyoPlugin_MyoVibrationType();
		extern MYOPLUGIN_API class UPackage* Z_Construct_UPackage_MyoPlugin();
		Singleton = GetStaticEnum(Z_Construct_UEnum_MyoPlugin_MyoVibrationType, Z_Construct_UPackage_MyoPlugin(), TEXT("MyoVibrationType"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_MyoVibrationType(MyoVibrationType_StaticEnum, TEXT("/Script/MyoPlugin"));
static class UEnum* MyoPose_StaticEnum()
{
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern MYOPLUGIN_API class UEnum* Z_Construct_UEnum_MyoPlugin_MyoPose();
		extern MYOPLUGIN_API class UPackage* Z_Construct_UPackage_MyoPlugin();
		Singleton = GetStaticEnum(Z_Construct_UEnum_MyoPlugin_MyoPose, Z_Construct_UPackage_MyoPlugin(), TEXT("MyoPose"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_MyoPose(MyoPose_StaticEnum, TEXT("/Script/MyoPlugin"));
static class UEnum* MyoArmDirection_StaticEnum()
{
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern MYOPLUGIN_API class UEnum* Z_Construct_UEnum_MyoPlugin_MyoArmDirection();
		extern MYOPLUGIN_API class UPackage* Z_Construct_UPackage_MyoPlugin();
		Singleton = GetStaticEnum(Z_Construct_UEnum_MyoPlugin_MyoArmDirection, Z_Construct_UPackage_MyoPlugin(), TEXT("MyoArmDirection"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_MyoArmDirection(MyoArmDirection_StaticEnum, TEXT("/Script/MyoPlugin"));
static class UEnum* MyoArm_StaticEnum()
{
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern MYOPLUGIN_API class UEnum* Z_Construct_UEnum_MyoPlugin_MyoArm();
		extern MYOPLUGIN_API class UPackage* Z_Construct_UPackage_MyoPlugin();
		Singleton = GetStaticEnum(Z_Construct_UEnum_MyoPlugin_MyoArm, Z_Construct_UPackage_MyoPlugin(), TEXT("MyoArm"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_MyoArm(MyoArm_StaticEnum, TEXT("/Script/MyoPlugin"));
class UScriptStruct* FMyoEmgData::StaticStruct()
{
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern MYOPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FMyoEmgData();
		extern MYOPLUGIN_API uint32 Get_Z_Construct_UScriptStruct_FMyoEmgData_CRC();
		extern MYOPLUGIN_API class UPackage* Z_Construct_UPackage_MyoPlugin();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FMyoEmgData, Z_Construct_UPackage_MyoPlugin(), TEXT("MyoEmgData"), sizeof(FMyoEmgData), Get_Z_Construct_UScriptStruct_FMyoEmgData_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FMyoEmgData(FMyoEmgData::StaticStruct, TEXT("/Script/MyoPlugin"));
static struct FScriptStruct_MyoPlugin_StaticRegisterNativesFMyoEmgData
{
	FScriptStruct_MyoPlugin_StaticRegisterNativesFMyoEmgData()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("MyoEmgData")),new UScriptStruct::TCppStructOps<FMyoEmgData>);
	}
} ScriptStruct_MyoPlugin_StaticRegisterNativesFMyoEmgData;
	void UMyoComponent::StaticRegisterNativesUMyoComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(UMyoComponent::StaticClass(),"ConvertToMyoOrientationSpace",(Native)&UMyoComponent::execConvertToMyoOrientationSpace);
		FNativeFunctionRegistrar::RegisterFunction(UMyoComponent::StaticClass(),"IsHubEnabled",(Native)&UMyoComponent::execIsHubEnabled);
		FNativeFunctionRegistrar::RegisterFunction(UMyoComponent::StaticClass(),"LeftMyo",(Native)&UMyoComponent::execLeftMyo);
		FNativeFunctionRegistrar::RegisterFunction(UMyoComponent::StaticClass(),"PrimaryMyo",(Native)&UMyoComponent::execPrimaryMyo);
		FNativeFunctionRegistrar::RegisterFunction(UMyoComponent::StaticClass(),"RightMyo",(Native)&UMyoComponent::execRightMyo);
		FNativeFunctionRegistrar::RegisterFunction(UMyoComponent::StaticClass(),"SetLockingPolicy",(Native)&UMyoComponent::execSetLockingPolicy);
	}
	IMPLEMENT_CLASS(UMyoComponent, 353449880);
	void UMyoController::StaticRegisterNativesUMyoController()
	{
		FNativeFunctionRegistrar::RegisterFunction(UMyoController::StaticClass(),"CalibrateArmOrientation",(Native)&UMyoController::execCalibrateArmOrientation);
		FNativeFunctionRegistrar::RegisterFunction(UMyoController::StaticClass(),"isOnLeftArm",(Native)&UMyoController::execisOnLeftArm);
		FNativeFunctionRegistrar::RegisterFunction(UMyoController::StaticClass(),"isOnRightArm",(Native)&UMyoController::execisOnRightArm);
		FNativeFunctionRegistrar::RegisterFunction(UMyoController::StaticClass(),"Lock",(Native)&UMyoController::execLock);
		FNativeFunctionRegistrar::RegisterFunction(UMyoController::StaticClass(),"SetStreamEmg",(Native)&UMyoController::execSetStreamEmg);
		FNativeFunctionRegistrar::RegisterFunction(UMyoController::StaticClass(),"Unlock",(Native)&UMyoController::execUnlock);
		FNativeFunctionRegistrar::RegisterFunction(UMyoController::StaticClass(),"VibrateDevice",(Native)&UMyoController::execVibrateDevice);
	}
	IMPLEMENT_CLASS(UMyoController, 2784329000);
	void IMyoInterface::DeviceDisabled()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_DeviceDisabled instead.");
	}
	void IMyoInterface::OnAccelerometerData(UMyoController* myo, FVector acceleration)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnAccelerometerData instead.");
	}
	void IMyoInterface::OnArmMoved(UMyoController* myo, FVector armAcceleration, FRotator armOrientation, FVector armGyro, MyoPose pose)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnArmMoved instead.");
	}
	void IMyoInterface::OnArmSync(UMyoController* myo, MyoArm arm, MyoArmDirection direction)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnArmSync instead.");
	}
	void IMyoInterface::OnArmUnsync(UMyoController* myo)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnArmUnsync instead.");
	}
	void IMyoInterface::OnConnect(UMyoController* myo)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnConnect instead.");
	}
	void IMyoInterface::OnDisconnect(UMyoController* myo)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnDisconnect instead.");
	}
	void IMyoInterface::OnEmgData(UMyoController* myo, FMyoEmgData data)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnEmgData instead.");
	}
	void IMyoInterface::OnGyroscopeData(UMyoController* myo, FVector gyro)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnGyroscopeData instead.");
	}
	void IMyoInterface::OnOrientationData(UMyoController* myo, FRotator orientation)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnOrientationData instead.");
	}
	void IMyoInterface::OnPair(UMyoController* myo)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnPair instead.");
	}
	void IMyoInterface::OnPose(UMyoController* myo, MyoPose pose)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnPose instead.");
	}
	void IMyoInterface::OnUnpair(UMyoController* myo)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnUnpair instead.");
	}
	void UMyoInterface::StaticRegisterNativesUMyoInterface()
	{
	}
	IMPLEMENT_CLASS(UMyoInterface, 1500770280);
	void IMyoInterface::Execute_DeviceDisabled(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UMyoInterface::StaticClass()));
		UFunction* const Func = O->FindFunction(MYOPLUGIN_DeviceDisabled);
		if (Func)
		{
			O->ProcessEvent(Func, NULL);
		}
	}
	void IMyoInterface::Execute_OnAccelerometerData(UObject* O, UMyoController* myo, FVector acceleration)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UMyoInterface::StaticClass()));
		MyoInterface_eventOnAccelerometerData_Parms Parms;
		UFunction* const Func = O->FindFunction(MYOPLUGIN_OnAccelerometerData);
		if (Func)
		{
			Parms.myo=myo;
			Parms.acceleration=acceleration;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void IMyoInterface::Execute_OnArmMoved(UObject* O, UMyoController* myo, FVector armAcceleration, FRotator armOrientation, FVector armGyro, MyoPose pose)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UMyoInterface::StaticClass()));
		MyoInterface_eventOnArmMoved_Parms Parms;
		UFunction* const Func = O->FindFunction(MYOPLUGIN_OnArmMoved);
		if (Func)
		{
			Parms.myo=myo;
			Parms.armAcceleration=armAcceleration;
			Parms.armOrientation=armOrientation;
			Parms.armGyro=armGyro;
			Parms.pose=pose;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void IMyoInterface::Execute_OnArmSync(UObject* O, UMyoController* myo, MyoArm arm, MyoArmDirection direction)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UMyoInterface::StaticClass()));
		MyoInterface_eventOnArmSync_Parms Parms;
		UFunction* const Func = O->FindFunction(MYOPLUGIN_OnArmSync);
		if (Func)
		{
			Parms.myo=myo;
			Parms.arm=arm;
			Parms.direction=direction;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void IMyoInterface::Execute_OnArmUnsync(UObject* O, UMyoController* myo)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UMyoInterface::StaticClass()));
		MyoInterface_eventOnArmUnsync_Parms Parms;
		UFunction* const Func = O->FindFunction(MYOPLUGIN_OnArmUnsync);
		if (Func)
		{
			Parms.myo=myo;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void IMyoInterface::Execute_OnConnect(UObject* O, UMyoController* myo)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UMyoInterface::StaticClass()));
		MyoInterface_eventOnConnect_Parms Parms;
		UFunction* const Func = O->FindFunction(MYOPLUGIN_OnConnect);
		if (Func)
		{
			Parms.myo=myo;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void IMyoInterface::Execute_OnDisconnect(UObject* O, UMyoController* myo)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UMyoInterface::StaticClass()));
		MyoInterface_eventOnDisconnect_Parms Parms;
		UFunction* const Func = O->FindFunction(MYOPLUGIN_OnDisconnect);
		if (Func)
		{
			Parms.myo=myo;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void IMyoInterface::Execute_OnEmgData(UObject* O, UMyoController* myo, FMyoEmgData data)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UMyoInterface::StaticClass()));
		MyoInterface_eventOnEmgData_Parms Parms;
		UFunction* const Func = O->FindFunction(MYOPLUGIN_OnEmgData);
		if (Func)
		{
			Parms.myo=myo;
			Parms.data=data;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void IMyoInterface::Execute_OnGyroscopeData(UObject* O, UMyoController* myo, FVector gyro)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UMyoInterface::StaticClass()));
		MyoInterface_eventOnGyroscopeData_Parms Parms;
		UFunction* const Func = O->FindFunction(MYOPLUGIN_OnGyroscopeData);
		if (Func)
		{
			Parms.myo=myo;
			Parms.gyro=gyro;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void IMyoInterface::Execute_OnOrientationData(UObject* O, UMyoController* myo, FRotator orientation)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UMyoInterface::StaticClass()));
		MyoInterface_eventOnOrientationData_Parms Parms;
		UFunction* const Func = O->FindFunction(MYOPLUGIN_OnOrientationData);
		if (Func)
		{
			Parms.myo=myo;
			Parms.orientation=orientation;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void IMyoInterface::Execute_OnPair(UObject* O, UMyoController* myo)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UMyoInterface::StaticClass()));
		MyoInterface_eventOnPair_Parms Parms;
		UFunction* const Func = O->FindFunction(MYOPLUGIN_OnPair);
		if (Func)
		{
			Parms.myo=myo;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void IMyoInterface::Execute_OnPose(UObject* O, UMyoController* myo, MyoPose pose)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UMyoInterface::StaticClass()));
		MyoInterface_eventOnPose_Parms Parms;
		UFunction* const Func = O->FindFunction(MYOPLUGIN_OnPose);
		if (Func)
		{
			Parms.myo=myo;
			Parms.pose=pose;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void IMyoInterface::Execute_OnUnpair(UObject* O, UMyoController* myo)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UMyoInterface::StaticClass()));
		MyoInterface_eventOnUnpair_Parms Parms;
		UFunction* const Func = O->FindFunction(MYOPLUGIN_OnUnpair);
		if (Func)
		{
			Parms.myo=myo;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void AMyoPlayerController::StaticRegisterNativesAMyoPlayerController()
	{
		FNativeFunctionRegistrar::RegisterFunction(AMyoPlayerController::StaticClass(),"ConvertToMyoOrientationSpace",(Native)&AMyoPlayerController::execConvertToMyoOrientationSpace);
		FNativeFunctionRegistrar::RegisterFunction(AMyoPlayerController::StaticClass(),"IsHubEnabled",(Native)&AMyoPlayerController::execIsHubEnabled);
		FNativeFunctionRegistrar::RegisterFunction(AMyoPlayerController::StaticClass(),"LeftMyo",(Native)&AMyoPlayerController::execLeftMyo);
		FNativeFunctionRegistrar::RegisterFunction(AMyoPlayerController::StaticClass(),"PrimaryMyo",(Native)&AMyoPlayerController::execPrimaryMyo);
		FNativeFunctionRegistrar::RegisterFunction(AMyoPlayerController::StaticClass(),"RightMyo",(Native)&AMyoPlayerController::execRightMyo);
		FNativeFunctionRegistrar::RegisterFunction(AMyoPlayerController::StaticClass(),"SetLockingPolicy",(Native)&AMyoPlayerController::execSetLockingPolicy);
	}
	IMPLEMENT_CLASS(AMyoPlayerController, 3238325548);
	void AMyoPluginActor::StaticRegisterNativesAMyoPluginActor()
	{
		FNativeFunctionRegistrar::RegisterFunction(AMyoPluginActor::StaticClass(),"ConvertToMyoOrientationSpace",(Native)&AMyoPluginActor::execConvertToMyoOrientationSpace);
		FNativeFunctionRegistrar::RegisterFunction(AMyoPluginActor::StaticClass(),"IsHubEnabled",(Native)&AMyoPluginActor::execIsHubEnabled);
		FNativeFunctionRegistrar::RegisterFunction(AMyoPluginActor::StaticClass(),"LeftMyo",(Native)&AMyoPluginActor::execLeftMyo);
		FNativeFunctionRegistrar::RegisterFunction(AMyoPluginActor::StaticClass(),"PrimaryMyo",(Native)&AMyoPluginActor::execPrimaryMyo);
		FNativeFunctionRegistrar::RegisterFunction(AMyoPluginActor::StaticClass(),"RightMyo",(Native)&AMyoPluginActor::execRightMyo);
		FNativeFunctionRegistrar::RegisterFunction(AMyoPluginActor::StaticClass(),"SetLockingPolicy",(Native)&AMyoPluginActor::execSetLockingPolicy);
	}
	IMPLEMENT_CLASS(AMyoPluginActor, 1605741356);
FName MYOPLUGIN_DeviceDisabled = FName(TEXT("DeviceDisabled"));
FName MYOPLUGIN_OnAccelerometerData = FName(TEXT("OnAccelerometerData"));
FName MYOPLUGIN_OnArmMoved = FName(TEXT("OnArmMoved"));
FName MYOPLUGIN_OnArmSync = FName(TEXT("OnArmSync"));
FName MYOPLUGIN_OnArmUnsync = FName(TEXT("OnArmUnsync"));
FName MYOPLUGIN_OnConnect = FName(TEXT("OnConnect"));
FName MYOPLUGIN_OnDisconnect = FName(TEXT("OnDisconnect"));
FName MYOPLUGIN_OnEmgData = FName(TEXT("OnEmgData"));
FName MYOPLUGIN_OnGyroscopeData = FName(TEXT("OnGyroscopeData"));
FName MYOPLUGIN_OnOrientationData = FName(TEXT("OnOrientationData"));
FName MYOPLUGIN_OnPair = FName(TEXT("OnPair"));
FName MYOPLUGIN_OnPose = FName(TEXT("OnPose"));
FName MYOPLUGIN_OnUnpair = FName(TEXT("OnUnpair"));
#if USE_COMPILED_IN_NATIVES
// Cross Module References
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FRotator();
	ENGINE_API class UClass* Z_Construct_UClass_UActorComponent();
	COREUOBJECT_API class UClass* Z_Construct_UClass_UObject();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector();
	ENGINE_API class UClass* Z_Construct_UClass_APlayerController();
	ENGINE_API class UClass* Z_Construct_UClass_AActor();

	MYOPLUGIN_API class UEnum* Z_Construct_UEnum_MyoPlugin_MyoStreamEmgType();
	MYOPLUGIN_API class UEnum* Z_Construct_UEnum_MyoPlugin_MyoUnlockType();
	MYOPLUGIN_API class UEnum* Z_Construct_UEnum_MyoPlugin_MyoLockingPolicy();
	MYOPLUGIN_API class UEnum* Z_Construct_UEnum_MyoPlugin_MyoVibrationType();
	MYOPLUGIN_API class UEnum* Z_Construct_UEnum_MyoPlugin_MyoPose();
	MYOPLUGIN_API class UEnum* Z_Construct_UEnum_MyoPlugin_MyoArmDirection();
	MYOPLUGIN_API class UEnum* Z_Construct_UEnum_MyoPlugin_MyoArm();
	MYOPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FMyoEmgData();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoComponent_ConvertToMyoOrientationSpace();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoComponent_IsHubEnabled();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoComponent_LeftMyo();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoComponent_PrimaryMyo();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoComponent_RightMyo();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoComponent_SetLockingPolicy();
	MYOPLUGIN_API class UClass* Z_Construct_UClass_UMyoComponent_NoRegister();
	MYOPLUGIN_API class UClass* Z_Construct_UClass_UMyoComponent();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoController_CalibrateArmOrientation();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoController_isOnLeftArm();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoController_isOnRightArm();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoController_Lock();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoController_SetStreamEmg();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoController_Unlock();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoController_VibrateDevice();
	MYOPLUGIN_API class UClass* Z_Construct_UClass_UMyoController_NoRegister();
	MYOPLUGIN_API class UClass* Z_Construct_UClass_UMyoController();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoInterface_DeviceDisabled();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoInterface_OnAccelerometerData();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoInterface_OnArmMoved();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoInterface_OnArmSync();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoInterface_OnArmUnsync();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoInterface_OnConnect();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoInterface_OnDisconnect();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoInterface_OnEmgData();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoInterface_OnGyroscopeData();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoInterface_OnOrientationData();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoInterface_OnPair();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoInterface_OnPose();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_UMyoInterface_OnUnpair();
	MYOPLUGIN_API class UClass* Z_Construct_UClass_UMyoInterface_NoRegister();
	MYOPLUGIN_API class UClass* Z_Construct_UClass_UMyoInterface();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_AMyoPlayerController_ConvertToMyoOrientationSpace();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_AMyoPlayerController_IsHubEnabled();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_AMyoPlayerController_LeftMyo();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_AMyoPlayerController_PrimaryMyo();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_AMyoPlayerController_RightMyo();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_AMyoPlayerController_SetLockingPolicy();
	MYOPLUGIN_API class UClass* Z_Construct_UClass_AMyoPlayerController_NoRegister();
	MYOPLUGIN_API class UClass* Z_Construct_UClass_AMyoPlayerController();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_AMyoPluginActor_ConvertToMyoOrientationSpace();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_AMyoPluginActor_IsHubEnabled();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_AMyoPluginActor_LeftMyo();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_AMyoPluginActor_PrimaryMyo();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_AMyoPluginActor_RightMyo();
	MYOPLUGIN_API class UFunction* Z_Construct_UFunction_AMyoPluginActor_SetLockingPolicy();
	MYOPLUGIN_API class UClass* Z_Construct_UClass_AMyoPluginActor_NoRegister();
	MYOPLUGIN_API class UClass* Z_Construct_UClass_AMyoPluginActor();
	MYOPLUGIN_API class UPackage* Z_Construct_UPackage_MyoPlugin();
	UEnum* Z_Construct_UEnum_MyoPlugin_MyoStreamEmgType()
	{
		UPackage* Outer=Z_Construct_UPackage_MyoPlugin();
		static UEnum* ReturnEnum = NULL;
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MyoStreamEmgType"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_STREAM_EMG_DISABLED")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_STREAM_EMG_ENABLED")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_STREAM_EMG_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/MyoDelegate.h"));
#endif
		}
		return ReturnEnum;
	}
	UEnum* Z_Construct_UEnum_MyoPlugin_MyoUnlockType()
	{
		UPackage* Outer=Z_Construct_UPackage_MyoPlugin();
		static UEnum* ReturnEnum = NULL;
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MyoUnlockType"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_UNLOCK_TIMED")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_UNLOCK_HOLD")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_UNLOCK_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/MyoDelegate.h"));
#endif
		}
		return ReturnEnum;
	}
	UEnum* Z_Construct_UEnum_MyoPlugin_MyoLockingPolicy()
	{
		UPackage* Outer=Z_Construct_UPackage_MyoPlugin();
		static UEnum* ReturnEnum = NULL;
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MyoLockingPolicy"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_LOCKING_POLICY_NONE")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_LOCKING_POLICY_STANDARD")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_LOCKING_POLICY_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/MyoDelegate.h"));
#endif
		}
		return ReturnEnum;
	}
	UEnum* Z_Construct_UEnum_MyoPlugin_MyoVibrationType()
	{
		UPackage* Outer=Z_Construct_UPackage_MyoPlugin();
		static UEnum* ReturnEnum = NULL;
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MyoVibrationType"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_VIBRATION_SHORT")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_VIBRATION_MEDIUM")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_VIBRATION_LONG")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_VIBRATION_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/MyoDelegate.h"));
#endif
		}
		return ReturnEnum;
	}
	UEnum* Z_Construct_UEnum_MyoPlugin_MyoPose()
	{
		UPackage* Outer=Z_Construct_UPackage_MyoPlugin();
		static UEnum* ReturnEnum = NULL;
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MyoPose"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_POSE_REST")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_POSE_FIST")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_POSE_WAVEIN")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_POSE_WAVEOUT")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_POSE_FINGERSPREAD")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_POSE_DOUBLETAP")), 5));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_POSE_MAX")), 255));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/MyoDelegate.h"));
#endif
		}
		return ReturnEnum;
	}
	UEnum* Z_Construct_UEnum_MyoPlugin_MyoArmDirection()
	{
		UPackage* Outer=Z_Construct_UPackage_MyoPlugin();
		static UEnum* ReturnEnum = NULL;
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MyoArmDirection"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_TOWARD_WRIST")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_TOWARD_ELBOW")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_DIRECTION_UNKNOWN")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/MyoDelegate.h"));
#endif
		}
		return ReturnEnum;
	}
	UEnum* Z_Construct_UEnum_MyoPlugin_MyoArm()
	{
		UPackage* Outer=Z_Construct_UPackage_MyoPlugin();
		static UEnum* ReturnEnum = NULL;
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MyoArm"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_ARM_RIGHT")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_ARM_LEFT")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_ARM_UNKNOWN")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("MYO_ARM_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/MyoDelegate.h"));
#endif
		}
		return ReturnEnum;
	}
	UScriptStruct* Z_Construct_UScriptStruct_FMyoEmgData()
	{
		UPackage* Outer=Z_Construct_UPackage_MyoPlugin();
		static UScriptStruct* ReturnStruct = NULL;
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("MyoEmgData"), RF_Public|RF_Transient|RF_Native) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FMyoEmgData>, EStructFlags(0x00000001));
			UProperty* NewProp_streams = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("streams"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(streams, FMyoEmgData), 0x0000000000000005);
			UProperty* NewProp_streams_Inner = new(EC_InternalUseOnlyConstructor, NewProp_streams, TEXT("streams"), RF_Public|RF_Transient|RF_Native) UIntProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(NewProp_streams, TEXT("Category"), TEXT("Emg Data Struct"));
			MetaData->SetValue(NewProp_streams, TEXT("ModuleRelativePath"), TEXT("Public/MyoDelegate.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FMyoEmgData_CRC() { return 414973683U; }
	UFunction* Z_Construct_UFunction_UMyoComponent_ConvertToMyoOrientationSpace()
	{
		struct MyoComponent_eventConvertToMyoOrientationSpace_Parms
		{
			FRotator orientation;
			FRotator converted;
		};
		UObject* Outer=Z_Construct_UClass_UMyoComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ConvertToMyoOrientationSpace"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(MyoComponent_eventConvertToMyoOrientationSpace_Parms));
			UProperty* NewProp_converted = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("converted"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(converted, MyoComponent_eventConvertToMyoOrientationSpace_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_orientation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("orientation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(orientation, MyoComponent_eventConvertToMyoOrientationSpace_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoUtilityFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Utility function to convert between UE and Myo space, call this on raw values to get them back in Myo space."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoComponent_IsHubEnabled()
	{
		struct MyoComponent_eventIsHubEnabled_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMyoComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsHubEnabled"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14020401, 65535, sizeof(MyoComponent_eventIsHubEnabled_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, MyoComponent_eventIsHubEnabled_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, MyoComponent_eventIsHubEnabled_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, MyoComponent_eventIsHubEnabled_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if Myo Hub is enabled, if its not it will remain so until restart."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoComponent_LeftMyo()
	{
		struct MyoComponent_eventLeftMyo_Parms
		{
			UMyoController* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMyoComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeftMyo"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14020401, 65535, sizeof(MyoComponent_eventLeftMyo_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, MyoComponent_eventLeftMyo_Parms), 0x0000000000000580, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Obtain controller pointer to current left arm myo if attached, otherwise returns none."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoComponent_PrimaryMyo()
	{
		struct MyoComponent_eventPrimaryMyo_Parms
		{
			UMyoController* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMyoComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PrimaryMyo"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14020401, 65535, sizeof(MyoComponent_eventPrimaryMyo_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, MyoComponent_eventPrimaryMyo_Parms), 0x0000000000000580, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Obtain controller pointer to any last paired myo, if you only have one myo and just want the primary myo, use this."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoComponent_RightMyo()
	{
		struct MyoComponent_eventRightMyo_Parms
		{
			UMyoController* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMyoComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RightMyo"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14020401, 65535, sizeof(MyoComponent_eventRightMyo_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, MyoComponent_eventRightMyo_Parms), 0x0000000000000580, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Obtain controller pointer to current right arm myo if attached, otherwise returns none."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoComponent_SetLockingPolicy()
	{
		struct MyoComponent_eventSetLockingPolicy_Parms
		{
			TEnumAsByte<MyoLockingPolicy> policy;
		};
		UObject* Outer=Z_Construct_UClass_UMyoComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLockingPolicy"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(MyoComponent_eventSetLockingPolicy_Parms));
			UProperty* NewProp_policy = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("policy"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(policy, MyoComponent_eventSetLockingPolicy_Parms), 0x0000000000000080, Z_Construct_UEnum_MyoPlugin_MyoLockingPolicy());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the Locking Policy of the Myo Hub see myo documentation for details."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UMyoComponent_NoRegister()
	{
		return UMyoComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UMyoComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage_MyoPlugin();
			OuterClass = UMyoComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UMyoComponent_ConvertToMyoOrientationSpace());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoComponent_IsHubEnabled());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoComponent_LeftMyo());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoComponent_PrimaryMyo());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoComponent_RightMyo());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoComponent_SetLockingPolicy());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoComponent_ConvertToMyoOrientationSpace()); // 3821936319
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoComponent_IsHubEnabled()); // 543868942
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoComponent_LeftMyo()); // 3818752210
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoComponent_PrimaryMyo()); // 39439185
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoComponent_RightMyo()); // 477083308
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoComponent_SetLockingPolicy()); // 1897104455
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Input Controller"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("MyoComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/MyoComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UMyoComponent(Z_Construct_UClass_UMyoComponent, TEXT("UMyoComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UMyoComponent);
	UFunction* Z_Construct_UFunction_UMyoController_CalibrateArmOrientation()
	{
		struct MyoController_eventCalibrateArmOrientation_Parms
		{
			FRotator direction;
		};
		UObject* Outer=Z_Construct_UClass_UMyoController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CalibrateArmOrientation"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(MyoController_eventCalibrateArmOrientation_Parms));
			UProperty* NewProp_direction = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("direction"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(direction, MyoController_eventCalibrateArmOrientation_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Calibrate the Orientation for Arm Space. Ask the user to point their arm to the screen, then call this function and all orientation will be\nin arm orientation space.\n@param myoId (in) device you wish to calibrate, use 0 to calibrate all.\n@param direction (in) orientation of the calibrated myo with respect to the user forward vector (R0,P0,Y0) specifies into the screen, (R0,P0,Y90) specifies pointing right, etc."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoController_isOnLeftArm()
	{
		struct MyoController_eventisOnLeftArm_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMyoController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("isOnLeftArm"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14020401, 65535, sizeof(MyoController_eventisOnLeftArm_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, MyoController_eventisOnLeftArm_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, MyoController_eventisOnLeftArm_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, MyoController_eventisOnLeftArm_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Myo Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Convenience Call, optionally check hand possession property"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoController_isOnRightArm()
	{
		struct MyoController_eventisOnRightArm_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UMyoController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("isOnRightArm"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14020401, 65535, sizeof(MyoController_eventisOnRightArm_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, MyoController_eventisOnRightArm_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, MyoController_eventisOnRightArm_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, MyoController_eventisOnRightArm_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Myo Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Convenience Call, optionally check hand possession property"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoController_Lock()
	{
		UObject* Outer=Z_Construct_UClass_UMyoController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Lock"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Tell the Myo to stay unlocked until told otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoController_SetStreamEmg()
	{
		struct MyoController_eventSetStreamEmg_Parms
		{
			TEnumAsByte<MyoStreamEmgType> streamType;
		};
		UObject* Outer=Z_Construct_UClass_UMyoController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetStreamEmg"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(MyoController_eventSetStreamEmg_Parms));
			UProperty* NewProp_streamType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("streamType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(streamType, MyoController_eventSetStreamEmg_Parms), 0x0000000000000080, Z_Construct_UEnum_MyoPlugin_MyoStreamEmgType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the EMG streaming mode for this Myo"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoController_Unlock()
	{
		struct MyoController_eventUnlock_Parms
		{
			TEnumAsByte<MyoUnlockType> type;
		};
		UObject* Outer=Z_Construct_UClass_UMyoController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Unlock"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(MyoController_eventUnlock_Parms));
			UProperty* NewProp_type = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("type"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(type, MyoController_eventUnlock_Parms), 0x0000000000000080, Z_Construct_UEnum_MyoPlugin_MyoUnlockType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Unlocks the Myo if locked to detect gestures\n@param type (in) type of unlock (short period or indefinite hold)"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoController_VibrateDevice()
	{
		struct MyoController_eventVibrateDevice_Parms
		{
			TEnumAsByte<MyoVibrationType> type;
		};
		UObject* Outer=Z_Construct_UClass_UMyoController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("VibrateDevice"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(MyoController_eventVibrateDevice_Parms));
			UProperty* NewProp_type = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("type"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(type, MyoController_eventVibrateDevice_Parms), 0x0000000000000080, Z_Construct_UEnum_MyoPlugin_MyoVibrationType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Vibrate the specified Myo with type intensity\n@param myoId (in) starting from 1, based on pairing priority. Call LeftMyoId/RightMyoId\n@param type (in) Options: Short, Medium, Long"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UMyoController_NoRegister()
	{
		return UMyoController::StaticClass();
	}
	UClass* Z_Construct_UClass_UMyoController()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage_MyoPlugin();
			OuterClass = UMyoController::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20000080;

				OuterClass->LinkChild(Z_Construct_UFunction_UMyoController_CalibrateArmOrientation());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoController_isOnLeftArm());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoController_isOnRightArm());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoController_Lock());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoController_SetStreamEmg());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoController_Unlock());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoController_VibrateDevice());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_myoId = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("myoId"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(myoId, UMyoController), 0x0000000000000015);
				UProperty* NewProp_bodySpaceNullAcceleration = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bodySpaceNullAcceleration"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(bodySpaceNullAcceleration, UMyoController), 0x0000000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_armSpaceCorrection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("armSpaceCorrection"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(armSpaceCorrection, UMyoController), 0x0000000000000015, Z_Construct_UScriptStruct_FRotator());
				UProperty* NewProp_armGyro = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("armGyro"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(armGyro, UMyoController), 0x0000000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_armOrientation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("armOrientation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(armOrientation, UMyoController), 0x0000000000000015, Z_Construct_UScriptStruct_FRotator());
				UProperty* NewProp_armAcceleration = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("armAcceleration"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(armAcceleration, UMyoController), 0x0000000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_xDirection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("xDirection"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(xDirection, UMyoController), 0x0000000000000015, Z_Construct_UEnum_MyoPlugin_MyoArmDirection());
				UProperty* NewProp_arm = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("arm"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(arm, UMyoController), 0x0000000000000015, Z_Construct_UEnum_MyoPlugin_MyoArm());
				UProperty* NewProp_gyro = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("gyro"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(gyro, UMyoController), 0x0000000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_orientation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("orientation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(orientation, UMyoController), 0x0000000000000015, Z_Construct_UScriptStruct_FRotator());
				UProperty* NewProp_acceleration = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("acceleration"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(acceleration, UMyoController), 0x0000000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_pose = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("pose"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(pose, UMyoController), 0x0000000000000015, Z_Construct_UEnum_MyoPlugin_MyoPose());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoController_CalibrateArmOrientation()); // 2424428357
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoController_isOnLeftArm()); // 616341269
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoController_isOnRightArm()); // 3890497635
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoController_Lock()); // 1288754903
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoController_SetStreamEmg()); // 577227782
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoController_Unlock()); // 4077226503
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoController_VibrateDevice()); // 1418495446
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("MyoController.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
				MetaData->SetValue(NewProp_myoId, TEXT("Category"), TEXT("Myo Frame"));
				MetaData->SetValue(NewProp_myoId, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
				MetaData->SetValue(NewProp_myoId, TEXT("ToolTip"), TEXT("Id identifying myo, used for calling functions"));
				MetaData->SetValue(NewProp_bodySpaceNullAcceleration, TEXT("Category"), TEXT("Myo Frame"));
				MetaData->SetValue(NewProp_bodySpaceNullAcceleration, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
				MetaData->SetValue(NewProp_bodySpaceNullAcceleration, TEXT("ToolTip"), TEXT("BodySpaceAcceleration(out) acceleration in calibrated body space, with gravity removed. (This value is used for velocity and position integration)"));
				MetaData->SetValue(NewProp_armSpaceCorrection, TEXT("Category"), TEXT("Myo Frame"));
				MetaData->SetValue(NewProp_armSpaceCorrection, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
				MetaData->SetValue(NewProp_armSpaceCorrection, TEXT("ToolTip"), TEXT("the correction rotation to transform raw into arm space"));
				MetaData->SetValue(NewProp_armGyro, TEXT("Category"), TEXT("Myo Frame"));
				MetaData->SetValue(NewProp_armGyro, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
				MetaData->SetValue(NewProp_armGyro, TEXT("ToolTip"), TEXT("gyro in arm space"));
				MetaData->SetValue(NewProp_armOrientation, TEXT("Category"), TEXT("Myo Frame"));
				MetaData->SetValue(NewProp_armOrientation, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
				MetaData->SetValue(NewProp_armOrientation, TEXT("ToolTip"), TEXT("orientation in arm space"));
				MetaData->SetValue(NewProp_armAcceleration, TEXT("Category"), TEXT("Myo Frame"));
				MetaData->SetValue(NewProp_armAcceleration, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
				MetaData->SetValue(NewProp_armAcceleration, TEXT("ToolTip"), TEXT("acceleration in arm space given in units of g"));
				MetaData->SetValue(NewProp_xDirection, TEXT("Category"), TEXT("Myo Frame"));
				MetaData->SetValue(NewProp_xDirection, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
				MetaData->SetValue(NewProp_xDirection, TEXT("ToolTip"), TEXT("toward wrist, toward elbow, unknown"));
				MetaData->SetValue(NewProp_arm, TEXT("Category"), TEXT("Myo Frame"));
				MetaData->SetValue(NewProp_arm, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
				MetaData->SetValue(NewProp_arm, TEXT("ToolTip"), TEXT("right, left, unknown"));
				MetaData->SetValue(NewProp_gyro, TEXT("Category"), TEXT("Myo Frame"));
				MetaData->SetValue(NewProp_gyro, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
				MetaData->SetValue(NewProp_gyro, TEXT("ToolTip"), TEXT("gyroscope vector in deg / s"));
				MetaData->SetValue(NewProp_orientation, TEXT("Category"), TEXT("Myo Frame"));
				MetaData->SetValue(NewProp_orientation, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
				MetaData->SetValue(NewProp_orientation, TEXT("ToolTip"), TEXT("orientation in rotator format"));
				MetaData->SetValue(NewProp_acceleration, TEXT("Category"), TEXT("Myo Frame"));
				MetaData->SetValue(NewProp_acceleration, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
				MetaData->SetValue(NewProp_acceleration, TEXT("ToolTip"), TEXT("acceleration in units of g"));
				MetaData->SetValue(NewProp_pose, TEXT("Category"), TEXT("Myo Frame"));
				MetaData->SetValue(NewProp_pose, TEXT("ModuleRelativePath"), TEXT("Public/MyoController.h"));
				MetaData->SetValue(NewProp_pose, TEXT("ToolTip"), TEXT("Can be rest, fist, waveIn, waveOut, fingersSpread, reserved1, DoubleTap, unknown"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UMyoController(Z_Construct_UClass_UMyoController, TEXT("UMyoController"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UMyoController);
	UFunction* Z_Construct_UFunction_UMyoInterface_DeviceDisabled()
	{
		UObject* Outer=Z_Construct_UClass_UMyoInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DeviceDisabled"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoEvents"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called when a problem occurs such as bluetooth usb device not being detected (unplugged).\nIf you receive this event further Myo events will not work until you plug in the hub and restart the application."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoInterface_OnAccelerometerData()
	{
		UObject* Outer=Z_Construct_UClass_UMyoInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnAccelerometerData"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08820800, 65535, sizeof(MyoInterface_eventOnAccelerometerData_Parms));
			UProperty* NewProp_acceleration = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("acceleration"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(acceleration, MyoInterface_eventOnAccelerometerData_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_myo = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("myo"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(myo, MyoInterface_eventOnAccelerometerData_Parms), 0x0000000000000080, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoEvents"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event on a Myo receiving acceleration data, typically each frame.\n@param myo (out) pointer to emitted myo controller class, branch to read other data.\n@param acceleration (out) acceleration in units of g."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoInterface_OnArmMoved()
	{
		UObject* Outer=Z_Construct_UClass_UMyoInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnArmMoved"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08820800, 65535, sizeof(MyoInterface_eventOnArmMoved_Parms));
			UProperty* NewProp_pose = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("pose"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(pose, MyoInterface_eventOnArmMoved_Parms), 0x0000000000000080, Z_Construct_UEnum_MyoPlugin_MyoPose());
			UProperty* NewProp_armGyro = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("armGyro"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(armGyro, MyoInterface_eventOnArmMoved_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_armOrientation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("armOrientation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(armOrientation, MyoInterface_eventOnArmMoved_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_armAcceleration = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("armAcceleration"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(armAcceleration, MyoInterface_eventOnArmMoved_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_myo = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("myo"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(myo, MyoInterface_eventOnArmMoved_Parms), 0x0000000000000080, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoEvents"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event (non-thalmic api) giving calibrated values"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoInterface_OnArmSync()
	{
		UObject* Outer=Z_Construct_UClass_UMyoInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnArmSync"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(MyoInterface_eventOnArmSync_Parms));
			UProperty* NewProp_direction = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("direction"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(direction, MyoInterface_eventOnArmSync_Parms), 0x0000000000000080, Z_Construct_UEnum_MyoPlugin_MyoArmDirection());
			UProperty* NewProp_arm = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("arm"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(arm, MyoInterface_eventOnArmSync_Parms), 0x0000000000000080, Z_Construct_UEnum_MyoPlugin_MyoArm());
			UProperty* NewProp_myo = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("myo"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(myo, MyoInterface_eventOnArmSync_Parms), 0x0000000000000080, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoEvents"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("On arm detection, typically after a wave out gesture\n@param myo (out) pointer to emitted myo controller class, branch to read other data.\n@param arm (out) 0 = right, 1 = left, 2 = unknown\n@param direction (out) 0 = toward wrist, 1 = toward elbow, 2 = unknown"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoInterface_OnArmUnsync()
	{
		UObject* Outer=Z_Construct_UClass_UMyoInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnArmUnsync"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(MyoInterface_eventOnArmUnsync_Parms));
			UProperty* NewProp_myo = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("myo"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(myo, MyoInterface_eventOnArmUnsync_Parms), 0x0000000000000080, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoEvents"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called when a myo has been removed from arm.\n@param myo (out) pointer to emitted myo controller class, branch to read other data."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoInterface_OnConnect()
	{
		UObject* Outer=Z_Construct_UClass_UMyoInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnConnect"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(MyoInterface_eventOnConnect_Parms));
			UProperty* NewProp_myo = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("myo"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(myo, MyoInterface_eventOnConnect_Parms), 0x0000000000000080, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoEvents"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event on a Myo connecting\n@param myo (out) pointer to emitted myo controller class, branch to read other data."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoInterface_OnDisconnect()
	{
		UObject* Outer=Z_Construct_UClass_UMyoInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnDisconnect"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(MyoInterface_eventOnDisconnect_Parms));
			UProperty* NewProp_myo = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("myo"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(myo, MyoInterface_eventOnDisconnect_Parms), 0x0000000000000080, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoEvents"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event on a Myo disconnecting\n@param myo (out) pointer to emitted myo controller class, branch to read other data."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoInterface_OnEmgData()
	{
		UObject* Outer=Z_Construct_UClass_UMyoInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnEmgData"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(MyoInterface_eventOnEmgData_Parms));
			UProperty* NewProp_data = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("data"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(data, MyoInterface_eventOnEmgData_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FMyoEmgData());
			UProperty* NewProp_myo = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("myo"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(myo, MyoInterface_eventOnEmgData_Parms), 0x0000000000000080, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoEvents"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called whenever a new raw streams are available.\n@param myo (out) pointer to emitted myo controller class, branch to read other data.\n@param data (out) struct containing an array of ints containing raw myo stream data; there are 8 streams."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoInterface_OnGyroscopeData()
	{
		UObject* Outer=Z_Construct_UClass_UMyoInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnGyroscopeData"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08820800, 65535, sizeof(MyoInterface_eventOnGyroscopeData_Parms));
			UProperty* NewProp_gyro = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("gyro"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(gyro, MyoInterface_eventOnGyroscopeData_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_myo = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("myo"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(myo, MyoInterface_eventOnGyroscopeData_Parms), 0x0000000000000080, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoEvents"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event on a Myo receiving gyroscope data, typically each frame.\n@param myo (out) pointer to emitted myo controller class, branch to read other data.\n@param gyro (out) gyroscope vector in deg/s."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoInterface_OnOrientationData()
	{
		UObject* Outer=Z_Construct_UClass_UMyoInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnOrientationData"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08820800, 65535, sizeof(MyoInterface_eventOnOrientationData_Parms));
			UProperty* NewProp_orientation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("orientation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(orientation, MyoInterface_eventOnOrientationData_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_myo = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("myo"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(myo, MyoInterface_eventOnOrientationData_Parms), 0x0000000000000080, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoEvents"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event on a Myo receiving orientation data, typically each frame.\n@param myo (out) pointer to emitted myo controller class, branch to read other data.\n@param orientation (out) orientation in rotator format."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoInterface_OnPair()
	{
		UObject* Outer=Z_Construct_UClass_UMyoInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnPair"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(MyoInterface_eventOnPair_Parms));
			UProperty* NewProp_myo = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("myo"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(myo, MyoInterface_eventOnPair_Parms), 0x0000000000000080, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoEvents"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event on a Myo pairing\n@param myo (out) pointer to emitted myo controller class, branch to read other data."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoInterface_OnPose()
	{
		UObject* Outer=Z_Construct_UClass_UMyoInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnPose"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(MyoInterface_eventOnPose_Parms));
			UProperty* NewProp_pose = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("pose"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(pose, MyoInterface_eventOnPose_Parms), 0x0000000000000080, Z_Construct_UEnum_MyoPlugin_MyoPose());
			UProperty* NewProp_myo = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("myo"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(myo, MyoInterface_eventOnPose_Parms), 0x0000000000000080, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoEvents"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event on a Myo detecting a pose.\n@param myo (out) pointer to emitted myo controller class, branch to read other data.\n@param pose (out): EMG pose, refer to Thalmic API rest, fist, waveIn, waveOut, fingersSpread, reserved1, DoubleTap, unknown"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UMyoInterface_OnUnpair()
	{
		UObject* Outer=Z_Construct_UClass_UMyoInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnUnpair"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(MyoInterface_eventOnUnpair_Parms));
			UProperty* NewProp_myo = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("myo"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(myo, MyoInterface_eventOnUnpair_Parms), 0x0000000000000080, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoEvents"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event on a Myo unpairing\n@param myo (out) pointer to emitted myo controller class, branch to read other data."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UMyoInterface_NoRegister()
	{
		return UMyoInterface::StaticClass();
	}
	UClass* Z_Construct_UClass_UMyoInterface()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_MyoPlugin();
			OuterClass = UMyoInterface::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20084081;

				OuterClass->LinkChild(Z_Construct_UFunction_UMyoInterface_DeviceDisabled());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoInterface_OnAccelerometerData());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoInterface_OnArmMoved());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoInterface_OnArmSync());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoInterface_OnArmUnsync());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoInterface_OnConnect());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoInterface_OnDisconnect());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoInterface_OnEmgData());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoInterface_OnGyroscopeData());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoInterface_OnOrientationData());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoInterface_OnPair());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoInterface_OnPose());
				OuterClass->LinkChild(Z_Construct_UFunction_UMyoInterface_OnUnpair());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoInterface_DeviceDisabled()); // 2055036313
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoInterface_OnAccelerometerData()); // 3453745508
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoInterface_OnArmMoved()); // 880028963
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoInterface_OnArmSync()); // 1567317621
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoInterface_OnArmUnsync()); // 1418523565
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoInterface_OnConnect()); // 1539238890
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoInterface_OnDisconnect()); // 515814350
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoInterface_OnEmgData()); // 2816423895
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoInterface_OnGyroscopeData()); // 165508590
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoInterface_OnOrientationData()); // 3208338723
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoInterface_OnPair()); // 3416959524
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoInterface_OnPose()); // 2767529250
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UMyoInterface_OnUnpair()); // 2216342808
				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UMyoInterface(Z_Construct_UClass_UMyoInterface, TEXT("UMyoInterface"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UMyoInterface);
	UFunction* Z_Construct_UFunction_AMyoPlayerController_ConvertToMyoOrientationSpace()
	{
		struct MyoPlayerController_eventConvertToMyoOrientationSpace_Parms
		{
			FRotator orientation;
			FRotator converted;
		};
		UObject* Outer=Z_Construct_UClass_AMyoPlayerController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ConvertToMyoOrientationSpace"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(MyoPlayerController_eventConvertToMyoOrientationSpace_Parms));
			UProperty* NewProp_converted = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("converted"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(converted, MyoPlayerController_eventConvertToMyoOrientationSpace_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_orientation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("orientation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(orientation, MyoPlayerController_eventConvertToMyoOrientationSpace_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoUtilityFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoPlayerController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Utility function to convert between UE and Myo space, call this on raw values to get them back in Myo space."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AMyoPlayerController_IsHubEnabled()
	{
		struct MyoPlayerController_eventIsHubEnabled_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AMyoPlayerController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsHubEnabled"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(MyoPlayerController_eventIsHubEnabled_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, MyoPlayerController_eventIsHubEnabled_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, MyoPlayerController_eventIsHubEnabled_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, MyoPlayerController_eventIsHubEnabled_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoPlayerController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if Myo Hub is enabled, if its not it will remain so until restart."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AMyoPlayerController_LeftMyo()
	{
		struct MyoPlayerController_eventLeftMyo_Parms
		{
			UMyoController* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AMyoPlayerController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeftMyo"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(MyoPlayerController_eventLeftMyo_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, MyoPlayerController_eventLeftMyo_Parms), 0x0000000000000580, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoPlayerController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Obtain controller pointer to current left arm myo if attached, otherwise returns none."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AMyoPlayerController_PrimaryMyo()
	{
		struct MyoPlayerController_eventPrimaryMyo_Parms
		{
			UMyoController* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AMyoPlayerController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PrimaryMyo"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(MyoPlayerController_eventPrimaryMyo_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, MyoPlayerController_eventPrimaryMyo_Parms), 0x0000000000000580, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoPlayerController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Obtain controller pointer to any last paired myo, if you only have one myo and just want the primary myo, use this."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AMyoPlayerController_RightMyo()
	{
		struct MyoPlayerController_eventRightMyo_Parms
		{
			UMyoController* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AMyoPlayerController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RightMyo"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(MyoPlayerController_eventRightMyo_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, MyoPlayerController_eventRightMyo_Parms), 0x0000000000000580, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoPlayerController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Obtain controller pointer to current right arm myo if attached, otherwise returns none."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AMyoPlayerController_SetLockingPolicy()
	{
		struct MyoPlayerController_eventSetLockingPolicy_Parms
		{
			TEnumAsByte<MyoLockingPolicy> policy;
		};
		UObject* Outer=Z_Construct_UClass_AMyoPlayerController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLockingPolicy"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(MyoPlayerController_eventSetLockingPolicy_Parms));
			UProperty* NewProp_policy = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("policy"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(policy, MyoPlayerController_eventSetLockingPolicy_Parms), 0x0000000000000080, Z_Construct_UEnum_MyoPlugin_MyoLockingPolicy());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoPlayerController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the Locking Policy of the Myo Hub see myo documentation for details."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AMyoPlayerController_NoRegister()
	{
		return AMyoPlayerController::StaticClass();
	}
	UClass* Z_Construct_UClass_AMyoPlayerController()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_APlayerController();
			Z_Construct_UPackage_MyoPlugin();
			OuterClass = AMyoPlayerController::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20800284;

				OuterClass->LinkChild(Z_Construct_UFunction_AMyoPlayerController_ConvertToMyoOrientationSpace());
				OuterClass->LinkChild(Z_Construct_UFunction_AMyoPlayerController_IsHubEnabled());
				OuterClass->LinkChild(Z_Construct_UFunction_AMyoPlayerController_LeftMyo());
				OuterClass->LinkChild(Z_Construct_UFunction_AMyoPlayerController_PrimaryMyo());
				OuterClass->LinkChild(Z_Construct_UFunction_AMyoPlayerController_RightMyo());
				OuterClass->LinkChild(Z_Construct_UFunction_AMyoPlayerController_SetLockingPolicy());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_AMyoPlayerController_ConvertToMyoOrientationSpace()); // 3683093412
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_AMyoPlayerController_IsHubEnabled()); // 1377743369
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_AMyoPlayerController_LeftMyo()); // 1083843994
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_AMyoPlayerController_PrimaryMyo()); // 2169491233
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_AMyoPlayerController_RightMyo()); // 3405197389
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_AMyoPlayerController_SetLockingPolicy()); // 1684652821
				OuterClass->ClassConfigName = FName(TEXT("Game"));
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UMyoInterface_NoRegister(), VTABLE_OFFSET(AMyoPlayerController, IMyoInterface), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Rendering Utilities|Transformation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("MyoPlayerController.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/MyoPlayerController.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AMyoPlayerController(Z_Construct_UClass_AMyoPlayerController, TEXT("AMyoPlayerController"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(AMyoPlayerController);
	UFunction* Z_Construct_UFunction_AMyoPluginActor_ConvertToMyoOrientationSpace()
	{
		struct MyoPluginActor_eventConvertToMyoOrientationSpace_Parms
		{
			FRotator orientation;
			FRotator converted;
		};
		UObject* Outer=Z_Construct_UClass_AMyoPluginActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ConvertToMyoOrientationSpace"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(MyoPluginActor_eventConvertToMyoOrientationSpace_Parms));
			UProperty* NewProp_converted = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("converted"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(converted, MyoPluginActor_eventConvertToMyoOrientationSpace_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_orientation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("orientation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(orientation, MyoPluginActor_eventConvertToMyoOrientationSpace_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoUtilityFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoPluginActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Utility function to convert between UE and Myo space, call this on raw values to get them back in Myo space."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AMyoPluginActor_IsHubEnabled()
	{
		struct MyoPluginActor_eventIsHubEnabled_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AMyoPluginActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsHubEnabled"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(MyoPluginActor_eventIsHubEnabled_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, MyoPluginActor_eventIsHubEnabled_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, MyoPluginActor_eventIsHubEnabled_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, MyoPluginActor_eventIsHubEnabled_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoPluginActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if Myo Hub is enabled, if its not it will remain so until restart."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AMyoPluginActor_LeftMyo()
	{
		struct MyoPluginActor_eventLeftMyo_Parms
		{
			UMyoController* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AMyoPluginActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeftMyo"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(MyoPluginActor_eventLeftMyo_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, MyoPluginActor_eventLeftMyo_Parms), 0x0000000000000580, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoPluginActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Obtain controller pointer to current left arm myo if attached, otherwise returns none."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AMyoPluginActor_PrimaryMyo()
	{
		struct MyoPluginActor_eventPrimaryMyo_Parms
		{
			UMyoController* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AMyoPluginActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PrimaryMyo"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(MyoPluginActor_eventPrimaryMyo_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, MyoPluginActor_eventPrimaryMyo_Parms), 0x0000000000000580, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoPluginActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Obtain controller pointer to any last paired myo, if you only have one myo and just want the primary myo, use this."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AMyoPluginActor_RightMyo()
	{
		struct MyoPluginActor_eventRightMyo_Parms
		{
			UMyoController* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AMyoPluginActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RightMyo"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(MyoPluginActor_eventRightMyo_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, MyoPluginActor_eventRightMyo_Parms), 0x0000000000000580, Z_Construct_UClass_UMyoController_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoPluginActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Obtain controller pointer to current right arm myo if attached, otherwise returns none."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AMyoPluginActor_SetLockingPolicy()
	{
		struct MyoPluginActor_eventSetLockingPolicy_Parms
		{
			TEnumAsByte<MyoLockingPolicy> policy;
		};
		UObject* Outer=Z_Construct_UClass_AMyoPluginActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLockingPolicy"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(MyoPluginActor_eventSetLockingPolicy_Parms));
			UProperty* NewProp_policy = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("policy"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(policy, MyoPluginActor_eventSetLockingPolicy_Parms), 0x0000000000000080, Z_Construct_UEnum_MyoPlugin_MyoLockingPolicy());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("MyoFunctions"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/MyoPluginActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set the Locking Policy of the Myo Hub see myo documentation for details."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AMyoPluginActor_NoRegister()
	{
		return AMyoPluginActor::StaticClass();
	}
	UClass* Z_Construct_UClass_AMyoPluginActor()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_MyoPlugin();
			OuterClass = AMyoPluginActor::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20800080;

				OuterClass->LinkChild(Z_Construct_UFunction_AMyoPluginActor_ConvertToMyoOrientationSpace());
				OuterClass->LinkChild(Z_Construct_UFunction_AMyoPluginActor_IsHubEnabled());
				OuterClass->LinkChild(Z_Construct_UFunction_AMyoPluginActor_LeftMyo());
				OuterClass->LinkChild(Z_Construct_UFunction_AMyoPluginActor_PrimaryMyo());
				OuterClass->LinkChild(Z_Construct_UFunction_AMyoPluginActor_RightMyo());
				OuterClass->LinkChild(Z_Construct_UFunction_AMyoPluginActor_SetLockingPolicy());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_AMyoPluginActor_ConvertToMyoOrientationSpace()); // 379798828
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_AMyoPluginActor_IsHubEnabled()); // 2236436298
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_AMyoPluginActor_LeftMyo()); // 3043149534
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_AMyoPluginActor_PrimaryMyo()); // 4127682054
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_AMyoPluginActor_RightMyo()); // 3679136844
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_AMyoPluginActor_SetLockingPolicy()); // 2950972606
				OuterClass->Interfaces.Add(FImplementedInterface(Z_Construct_UClass_UMyoInterface_NoRegister(), VTABLE_OFFSET(AMyoPluginActor, IMyoInterface), false ));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("MyoPluginActor.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/MyoPluginActor.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Placeable Actor that receives Myo input and pose updates.\nUse or Extend to receive event notifications."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AMyoPluginActor(Z_Construct_UClass_AMyoPluginActor, TEXT("AMyoPluginActor"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(AMyoPluginActor);
	UPackage* Z_Construct_UPackage_MyoPlugin()
	{
		static UPackage* ReturnPackage = NULL;
		if (!ReturnPackage)
		{
			ReturnPackage = CastChecked<UPackage>(StaticFindObjectFast(UPackage::StaticClass(), NULL, FName(TEXT("/Script/MyoPlugin")), false, false));
			ReturnPackage->PackageFlags |= PKG_CompiledIn | 0x00000000;
			FGuid Guid;
			Guid.A = 0xA6600ECA;
			Guid.B = 0x4B3D68D6;
			Guid.C = 0x00000000;
			Guid.D = 0x00000000;
			ReturnPackage->SetGuid(Guid);

		}
		return ReturnPackage;
	}
#endif

PRAGMA_ENABLE_DEPRECATION_WARNINGS
